#parse("definitions.vm")
import org.jetbrains.research.kex.smt.${solver}SMTConverter
import org.jetbrains.research.kex.state.*
import org.jetbrains.research.kex.state.predicate.*
import org.jetbrains.research.kex.state.term.*
import org.jetbrains.research.kex.state.transformer.Memspaced
import org.jetbrains.research.kfg.ir.Class
import org.jetbrains.research.kfg.ir.value.instruction.BinaryOpcode
import org.jetbrains.research.kfg.ir.value.instruction.CmpOpcode
import org.jetbrains.research.kex.config.GlobalConfig

val defaultAllocSize = GlobalConfig.getIntValue("smt", "defaultAllocationSize", 1024)

object ${solver}Converter : ${solver}SMTConverter(), Loggable {
    fun convert(ps: PredicateState, ef: $factory, ctx: ${solver}Context, extractPath: Boolean = false): Bool_ = when (ps) {
#set($states = ["Basic", "Chain", "Choice"])
#foreach($state in $states)
        is ${state}State -> convert(ps, ef, ctx, extractPath)
#end
        else -> unreachable { log.error("Unknown PS type: $ps") }
    }

    fun convert(basic: BasicState, ef: $factory, ctx: ${solver}Context, extractPath: Boolean = false): Bool_ =
        basic.predicates().foldRight(ef.makeTrue()) { predicate, acc -> acc and convert(predicate, ef, ctx) }

    fun convert(chain: ChainState, ef: $factory, ctx: ${solver}Context, extractPath: Boolean = false): Bool_ =
        ef.makeTrue() and convert(chain.base, ef, ctx) and convert(chain.curr, ef, ctx)

    fun convert(choice: ChoiceState, ef: $factory, ctx: ${solver}Context, extractPath: Boolean = false): Bool_ {
        var res = ef.makeFalse()
        val contexts = mutableMapOf< Bool_, ${solver}Context >()
        for (branch in choice) {
            val newCtx = ${solver}Context(ctx)
            val state = convert(branch, ef, newCtx, extractPath)

            res = res or state
            if (!extractPath) {
                val path = branch.filterByType(PredicateType.Path())
                contexts[convert(path, ef, newCtx, true)] = newCtx
            }
        }
        ctx.switchOn("choice", contexts)
        return res
    }

#set($predicates = ["ArrayStore", "Call", "Catch", "DefaultSwitch", "Equality", "FieldStore", "NewArray", "New", "Throw"])
    fun convert(predicate: Predicate, ef: $factory, ctx: ${solver}Context): Bool_ = when (predicate) {
#foreach($predicate in $predicates)
        is ${predicate}Predicate -> convert(predicate, ef, ctx)
#end
        else -> unreachable { log.error("Unknown predicate type: $predicate") }
    }

    fun convert(store: ArrayStorePredicate, ef: $factory, ctx: ${solver}Context): Bool_ {
        val memspace = (store.getArrayRef().type as? Memspaced<*>)?.memspace ?: 0
        val ptr = convert(store.getArrayRef(), ef, ctx) as? Ptr_ ?: unreachable { log.error("Non-ptr ref term in `store`") }
        val shift = convert(store.getIndex(), ef, ctx) as? Int_ ?: unreachable { log.error("Non-int index term in `store`") }
        val element = Ptr_.forceCast(ptr + (shift + ${factory}.getTypeSize(store.getComponentType())))
        val value = convert(store.getValue(), ef, ctx)
        ctx.writeMemory(element, value, memspace)
        return ef.makeTrue()
    }

    fun convert(call: CallPredicate, ef: $factory, ctx: ${solver}Context): Bool_ = ef.makeTrue()
    fun convert(catch: CatchPredicate, ef: $factory, ctx: ${solver}Context): Bool_ = ef.makeTrue()
    fun convert(`throw`: ThrowPredicate, ef: $factory, ctx: ${solver}Context): Bool_ = ef.makeTrue()

    fun convert(defaultswitch: DefaultSwitchPredicate, ef: $factory, ctx: ${solver}Context): Bool_ {
        var res = ef.makeTrue()
        val cond = convert(defaultswitch.getCond(), ef, ctx) as? Int_
                        ?: unreachable { log.error("Non-integer term in switch") }
        for (case in defaultswitch.getCases()) {
            val case_ = convert(case, ef, ctx) as? Int_ ?: unreachable { log.error("Non-integer term in switch") }
            res = res and (cond neq case_).toBool()
        }
        return res
    }

    fun convert(equality: EqualityPredicate, ef: $factory, ctx: ${solver}Context): Bool_ {
        val lhv = convert(equality.getLhv(), ef, ctx)
        val rhv = convert(equality.getRhv(), ef, ctx)
        return lhv eq rhv
    }

    fun convert(store: FieldStorePredicate, ef: $factory, ctx: ${solver}Context): Bool_ {
        val value = convert(store.getValue(), ef, ctx)
        val memspace = (store.getOwner().type as? Memspaced<*>)?.memspace ?: 0
        val ptr = convert(store.getOwner(), ef, ctx) as? Ptr_
                ?: unreachable { log.error("Non-ptr ref in field load") }
        val name = store.getFieldName().name
        val offset = Z3ExprFactory.getFieldOffset(store.getClass(), Class.FieldKey(name, store.fieldType))

        val fieldptr = Ptr_.forceCast(ptr + offset)
        ctx.writeMemory(fieldptr, value, memspace)
        return ef.makeTrue()
    }

    fun convert(newarray: NewArrayPredicate, ef: $factory, ctx: ${solver}Context): Bool_ {
        val memspace = (newarray.getLhv().type as? Memspaced<*>)?.memspace ?: 0
        val lhv = convert(newarray.getLhv(), ef, ctx) as? Ptr_ ?: unreachable { log.error("Non-ptr term in `new`") }
            val elementSize = ${factory}.getTypeSizeExpanded(newarray.elementType)
            val totalSize = newarray.getDimentions().fold(elementSize) { acc: Int, term: Term ->
            acc * ((term as? ConstIntTerm)?.value ?: defaultAllocSize)
        }
        val ptr = ctx.getLocalPtr(memspace, totalSize)
        ctx.writeBound(ptr, ef.makeIntConst(totalSize), memspace)
        return lhv eq ptr
    }

    fun convert(new: NewPredicate, ef: $factory, ctx: ${solver}Context): Bool_ {
        val memspace = (new.getLhv().type as? Memspaced<*>)?.memspace ?: 0
        val lhv = convert(new.getLhv(), ef, ctx) as? Ptr_ ?: unreachable { log.error("Non-ptr term in `new`") }
        val elementSize = ${factory}.getTypeSizeExpanded(new.getLhv().type)
        return lhv eq ctx.getLocalPtr(memspace, elementSize)
    }

#set($terms = ["Argument", "ArrayLength", "ArrayLoad", "Binary", "Call", "Cast", "Cmp",
    "ConstBool", "ConstByte", "ConstChar", "ConstClass", "ConstDouble", "ConstFloat", "ConstInt", "ConstLong",
    "ConstShort", "ConstString", "FieldLoad", "InstanceOf", "Neg", "Null", "ReturnValue", "Value"])
    fun convert(term: Term, ef: $factory, ctx: ${solver}Context): Dynamic_ = when (term) {
#foreach($term in $terms)
        is ${term}Term -> convert(term, ef, ctx)
#end
        else -> unreachable { log.error("Unknown term type: $term") }
    }

    fun convert(argument: ArgumentTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ = ef.getVarByType(argument.type, argument.name)

    fun convert(arraylength: ArrayLengthTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ {
        val memspace = (arraylength.getArrayRef().type as? Memspaced<*>)?.memspace ?: 0
        val ptr = convert(arraylength.getArrayRef(), ef, ctx) as? Ptr_
                ?: unreachable { log.error("Non-ptr term in `arraylength`") }

        return ctx.readBound(ptr, memspace)
    }

    fun convert(arrayload: ArrayLoadTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ {
        val memspace = (arrayload.getArrayRef().type as? Memspaced<*>)?.memspace ?: 0
        val arrayref = convert(arrayload.getArrayRef(), ef, ctx) as? Ptr_
                            ?: unreachable { log.error("Non-ptr operand of array load") }
        val index = convert(arrayload.getIndex(), ef, ctx) as? Int_
                            ?: unreachable { log.error("Non-integer index of array load") }
        val valuePtr = Ptr_.forceCast(arrayref + index)
        val baseBound = ctx.readBound(arrayref, memspace)
        val ptrBound = Int_.forceCast(baseBound - index)
        ctx.writeBound(valuePtr, ptrBound, memspace)

        val ret = ctx.readMemory(valuePtr, ${factory}.getTypeSize(arrayload.type), memspace)
        return when (arrayload.type) {
            is LongType -> Long_.forceCast(ret)
            is Integral -> Int_.forceCast(ret)
            is FloatType -> Float_.forceCast(ret)
            is DoubleType -> Double_.forceCast(ret)
            is ClassType -> Ptr_.forceCast(ret)
            is ArrayType -> Ptr_.forceCast(ret)
            else -> unreachable { log.error("Unable to cast load result $ret to ${ arrayload.type }") }
        }
    }

    fun convert(binary: BinaryTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ {
        val lhv = convert(binary.getLhv(), ef, ctx)
        val rhv = convert(binary.getRhv(), ef, ctx)
        return when (binary.opcode) {
            is BinaryOpcode.Add -> lhv + rhv
            is BinaryOpcode.Sub -> lhv - rhv
            is BinaryOpcode.Mul -> lhv * rhv
            is BinaryOpcode.Div -> lhv / rhv
            is BinaryOpcode.Rem -> lhv % rhv
            is BinaryOpcode.Shl -> lhv shl rhv
            is BinaryOpcode.Shr -> lhv ashr rhv
            is BinaryOpcode.Ushr -> lhv shr rhv
            is BinaryOpcode.And -> lhv and rhv
            is BinaryOpcode.Or -> lhv or rhv
            is BinaryOpcode.Xor -> lhv xor rhv
        }
    }

    fun convert(call: CallTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ =
        ef.getVarByType(call.type, call.name)

    fun convert(cast: CastTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ {
        val op = convert(cast.getOperand(), ef, ctx)
        return when (cast.type) {
            is LongType -> Long_.forceCast(op)
            is Integral -> Int_.forceCast(op)
            is FloatType -> Float_.forceCast(op)
            is DoubleType -> Double_.forceCast(op)
            is ClassType -> Ptr_.forceCast(op)
            is ArrayType -> Ptr_.forceCast(op)
            else -> unreachable { log.error("Invalid cast $cast") }
        }
    }

#macro(cmp $opcode $default $type)
            is CmpOpcode.$opcode -> {
                val lhvf = lhv as? $type ?: unreachable { log.error("Non-${type.toLowerCase()} operands of `${opcode.toLowerCase()}`") }
                val rhvf = rhv as? $type ?: unreachable { log.error("Non-${type.toLowerCase()} operands of `${opcode.toLowerCase()}`") }
                val cases = mapOf(
                    (lhvf gt rhvf) to ef.makeIntConst(1),
                    (lhvf eq rhvf) to ef.makeIntConst(0),
                    (lhvf lt rhvf) to ef.makeIntConst(-1)
                )
                ef.switch(cases, ef.makeIntConst($default))
            }
#end
    fun convert(cmp: CmpTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ {
        val lhv = convert(cmp.getLhv(), ef, ctx)
        val rhv = convert(cmp.getRhv(),ef, ctx)
#set($opcodes = ["Eq", "Neq", "Lt", "Gt", "Le", "Ge"])
        return when (cmp.opcode) {
#foreach($opcode in $opcodes)
            is CmpOpcode.$opcode -> lhv ${opcode.toLowerCase()} rhv
#end
#cmp("Cmp", 1, "Long_")
#cmp("Cmpg", 1, "Float_")
#cmp("Cmpl", -1, "Double_")
        }
    }

    fun convert(const: ConstBoolTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ = ef.makeBoolConst(const.value)
    fun convert(const: ConstByteTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ = ef.makeIntConst(const.value.toInt())
    fun convert(const: ConstCharTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ = ef.makeIntConst(const.value.toInt())

    fun convert(const: ConstClassTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ =
        ef.getVarByType(const.type, const.name)

    fun convert(const: ConstDoubleTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ = ef.makeDoubleConst(const.value)
    fun convert(const: ConstFloatTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ = ef.makeFloatConst(const.value)
    fun convert(const: ConstIntTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ = ef.makeIntConst(const.value)
    fun convert(const: ConstLongTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ = ef.makeLongConst(const.value)
    fun convert(const: ConstShortTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ = ef.makeIntConst(const.value.toInt())

    fun convert(const: ConstStringTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ {
        val memspace = (const.type as? Memspaced<*>)?.memspace ?: 0

        val size = const.name.length
        val res = ctx.getLocalPtr(memspace, size)
        ctx.writeBound(res, ef.makeIntConst(size), memspace)
        return res
    }

    fun convert(fieldload: FieldLoadTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ {
        val memspace = (fieldload.getOwner().type as? Memspaced<*>)?.memspace ?: 0
        val obj = convert(fieldload.getOwner(), ef, ctx) as? Ptr_
            ?: unreachable { log.error("Non-ptr ref in field load") }
        val name = fieldload.getFieldName().name
        val offset = Z3ExprFactory.getFieldOffset(fieldload.getClass(), Class.FieldKey(name, fieldload.type))
        val baseBound = ctx.readBound(obj, memspace)

        val fieldptr = Ptr_.forceCast(obj + offset)
        ctx.writeBound(fieldptr, Int_.forceCast(baseBound - offset), memspace)
        val res = ctx.readMemory(fieldptr, Z3ExprFactory.getTypeSize(fieldload.type), memspace)
        return when (fieldload.type) {
            is LongType -> Long_.forceCast(res)
            is Integral -> Int_.forceCast(res)
            is FloatType -> Float_.forceCast(res)
            is DoubleType -> Double_.forceCast(res)
            is ClassType -> Ptr_.forceCast(res)
            is ArrayType -> Ptr_.forceCast(res)
            else -> unreachable { log.error("Unable to cast load result $res to ${ fieldload.type }") }
        }
    }

    fun convert(instanceof: InstanceOfTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ =
        ef.getVarByType(instanceof.type, instanceof.name)

    fun convert(neg: NegTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ {
        val operand = convert(neg.getOperand(), ef, ctx) as? Bool_ ?: unreachable { log.error("Non-bool term in `neg`") }
        return !operand
    }

    fun convert(`null`: NullTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ = ef.makeNull()

    fun convert(`return`: ReturnValueTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ =
        ef.getVarByType(`return`.type, `return`.name)

    fun convert(value: ValueTerm, ef: $factory, ctx: ${solver}Context): Dynamic_ =
        ef.getVarByType(value.type, value.name)
}