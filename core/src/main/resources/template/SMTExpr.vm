#parse("definitions.vm")
import org.jetbrains.research.kex.smt.${solver}SMTExpr
import kotlin.math.max

private val engine = ${solver}Engine

fun defaultAxiom(ctx: $context) = engine.makeBooleanConst(ctx, true)

fun spliceAxioms(ctx: $context, lhv: $expr, rhv: $expr) = when {
    engine.equality(ctx, lhv, defaultAxiom(ctx)) -> rhv
    engine.equality(ctx, rhv, defaultAxiom(ctx)) -> lhv
    else -> engine.conjunction(ctx, lhv, rhv)
}

fun spliceAxioms(ctx: $context, e0: $expr, e1: $expr, e2: $expr) = when {
    engine.equality(ctx, e0, defaultAxiom(ctx)) -> spliceAxioms(ctx, e1, e2)
    engine.equality(ctx, e1, defaultAxiom(ctx)) -> spliceAxioms(ctx, e0, e2)
    engine.equality(ctx, e2, defaultAxiom(ctx)) -> spliceAxioms(ctx, e0, e1)
    else -> engine.conjunction(ctx, e0, e1, e2)
}

open class $valexpr : ${solver}SMTExpr, Loggable {
    companion object {
        inline fun < reified Type : $valexpr> getStaticSort(ctx: $context) = when (Type::class) {
#foreach($class in $exprClasses)
            $class::class -> ${class}.getStaticSort(ctx)
#end
            else -> unreachable { loggerFor($valexpr::class).error("Trying to get static sort of non-simple SMTExpr") }
        }

        inline fun < reified Type : $valexpr > getStaticBitsize(ctx: $context) = when (Type::class) {
#foreach($class in $exprClasses)
            $class::class -> ${class}.getStaticBitsize(ctx)
#end
            else -> unreachable { loggerFor($valexpr::class).error("Trying to get static bitsize of non-simple SMTExpr") }
        }
    }

    val ctx: $context
    val expr: $expr
    val axiom: $expr

    constructor(ctx: $context, expr: $expr, axiom: $expr) : super() {
        this.ctx = ctx
        this.expr = expr
        this.axiom = axiom
    }

    constructor(ctx: $context, expr: $expr) : super() {
        this.ctx = ctx
        this.expr = expr
        this.axiom = defaultAxiom(ctx)
    }

    constructor(other: $valexpr) : this(other.ctx, other.expr, other.axiom)

    override fun toString() = engine.toString(ctx, expr)
    override fun hashCode() = defaultHashCode(engine.hash(ctx, expr), engine.hash(ctx, axiom))
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other?.javaClass != this.javaClass) return false
        other as $valexpr
        return engine.equality(ctx, expr, other.expr) and engine.equality(ctx, expr, other.axiom)
    }

    fun name() = engine.name(ctx, expr)
    fun getSort() = engine.getSort(ctx, expr)

    fun asAxiom() = spliceAxioms(ctx, expr, axiom)
    open fun withAxiom(ax: $valexpr) = $valexpr(ctx, expr, ax.asAxiom())

    open fun simplify() = $valexpr(ctx, engine.simplify(ctx, expr), engine.simplify(ctx, expr))

    infix fun eq(other: $valexpr): $Bool = when {
#foreach($class in $exprClasses)
        this is $class && other is $class -> eq(other)
#end
        else -> unreachable { log.error("Invalid operands of `eq`: $this and $other") }
    }
}

#macro(constructors $class)
    constructor(ctx: $context, expr: $expr) : super(ctx, expr) {
        assert(engine.is$class(ctx, expr)) { log.error("$class created from non-${class.toLowerCase()} expr") }
    }

    constructor(ctx: $context, expr: $expr, axiom: $expr) : super(ctx, expr, axiom) {
        assert(engine.is$class(ctx, expr)) { log.error("$class created from non-${class.toLowerCase()} expr") }
    }

    constructor(other: $valexpr) : super(other) {
        assert(engine.is$class(ctx, expr)) { log.error("$class created from non-${class.toLowerCase()} expr") }
    }
#end

#macro(makeVars $name $fresh)
        fun make${name}Var(ctx: $context, name: String) = $self(ctx, engine.makeVar(ctx, getStaticSort(ctx), name, $fresh))
        fun make${name}Var(ctx: $context, name: String, axiomize: ($self) -> $Bool): $self {
            val new = $self(ctx, engine.makeVar(ctx, getStaticSort(ctx), name, $fresh))
            val axiom = axiomize(new)
            return new.withAxiom(axiom)
        }
#end

#macro(generateStatics $self $basetype)
        fun makeConst(ctx: $context, value: $basetype) = $self(ctx, engine.make${basetype}Const(ctx, value))
#makeVars("", false)
#makeVars("Fresh", true)
#end

#macro(generateClass $fullname $simplename $modifiers $parent $staticSort $basetype)
#set($self = $fullname)
$modifiers class $fullname : $parent {
    companion object {
        fun getStaticBitsize(ctx: $context) = engine.getSortBitsize(ctx, getStaticSort(ctx))
        fun getStaticSort(ctx: $context) = $staticSort
#generateStatics($fullname, $basetype)
    }

#constructors($simplename)
#end

#generateClass($Bool, "Bool", "", $valexpr, "engine.getBoolSort(ctx)", "Boolean")
    override fun withAxiom(ax: $valexpr) = $self(ctx, expr, spliceAxioms(ctx, axiom, ax.expr, ax.axiom))

    override fun simplify() = $self(super.simplify())

#set($opcodes = ["EQ", "NEQ", "AND", "OR", "XOR", "IMPLIES", "IFF"])
#foreach($opcode in $opcodes)
    infix fun ${opcode.toLowerCase()}(other: $self) =
    $self(ctx, engine.binary(ctx, SMTEngine.Opcode.${opcode}, expr, other.expr), spliceAxioms(ctx, axiom, other.axiom))
#end
}

#generateClass($Bitvector, "BV", "open", $valexpr, "engine.getBVSort(ctx, SMTEngine.WORD * 8)", "Long")
    override fun withAxiom(ax: $valexpr) = $self(ctx, expr, spliceAxioms(ctx, axiom, ax.expr, ax.axiom))

    fun getBitsize() = engine.bvBitsize(ctx, getSort())
    open fun extract(high: Int, low: Int) = $self(ctx, engine.extract(ctx, expr, high, low), axiom)

    open fun binary(opcode: SMTEngine.Opcode, other: $self): $valexpr {
        val maxsize = max(getBitsize(), other.getBitsize())
        val lhv = engine.sext(ctx, maxsize, expr)
        val rhv = engine.sext(ctx, maxsize, other.expr)

        val nexpr = engine.binary(ctx, opcode, lhv, rhv)
        val nax = spliceAxioms(ctx, axiom, other.axiom)
        return $valexpr(ctx, nexpr, nax)
    }

#set($opcodes = ["EQ", "NEQ", "GT", "GE", "LT", "LE"])
#foreach($opcode in $opcodes)
    infix fun ${opcode.toLowerCase()}(other: $self) = binary(SMTEngine.Opcode.$opcode, other).toBool()
#end
#set($opcodes = ["ADD", "SUB", "MUL", "DIVIDE", "MOD", "SHL", "SHR", "ASHR", "AND", "OR", "XOR"])
#foreach($opcode in $opcodes)
    infix fun ${opcode.toLowerCase()}(other: $self) = binary(SMTEngine.Opcode.$opcode, other).toBV()
#end

#set($opcodes = ["ADD", "SUB", "MUL", "DIVIDE"])
#foreach($opcode in $opcodes)
    infix fun ${opcode.toLowerCase()}(other: Int) =
        binary(SMTEngine.Opcode.$opcode, $self(ctx, engine.makeNumericConst(ctx, engine.getBVSort(ctx, getBitsize()), other.toLong()))).toBV()
#end

    operator fun plus(other: $self) = add(other)
    operator fun plus(other: Int) = add(other)
    operator fun minus(other: $self) = sub(other)
    operator fun minus(other: Int) = sub(other)
    operator fun times(other: $self) = mul(other)
    operator fun times(other: Int) = mul(other)
    operator fun div(other: $self) = divide(other)
    operator fun div(other: Int) = divide(other)
    operator fun rem(other: $self) = mod(other)
}

#set($widths = [32, 64])
#foreach($width in $widths)
class $self$width : $self {
#if($width == 32)
    #set($base = "Int")
#else
    #set($base = "Long")
#end
    companion object {
        const val BITSIZE = $width
        fun getStaticBitsize(ctx: $context) = BITSIZE

        fun getStaticSort(ctx: $context) = engine.getBVSort(ctx, BITSIZE)
#generateStatics("$self$width", $base)
    }

    #constructors("BV")
    override fun extract(high: Int, low: Int) = $self(ctx, engine.extract(ctx, expr, high, low), axiom)
    override fun withAxiom(ax: $valexpr) = $self$width(ctx, expr, spliceAxioms(ctx, axiom, ax.expr, ax.axiom))
    override fun binary(opcode: SMTEngine.Opcode, other: $self) =
        if (other is $self$width) {
            $valexpr(ctx, engine.binary(ctx, opcode, expr, other.expr), spliceAxioms(ctx, axiom, other.axiom))
        } else super.binary(opcode, other)
}

#end

#set($floats = ["Float", "Double"])
#foreach($float in $floats)
#generateClass("$solver$float", $float, "", $valexpr, "engine.get${float}Sort(ctx)", $float)
    override fun withAxiom(ax: $valexpr) = $self(ctx, expr, spliceAxioms(ctx, axiom, ax.expr, ax.axiom))

    fun getEBitsize() = engine.floatEBitsize(ctx, getSort())
    fun getSBitsize() = engine.floatSBitsize(ctx, getSort())

    fun binary(opcode: SMTEngine.Opcode, other: $self): $valexpr {
        val nexpr = engine.binary(ctx, opcode, expr, other.expr)
        val nax = spliceAxioms(ctx, axiom, other.axiom)
        return $valexpr(ctx, nexpr, nax)
    }

#set($opcodes = ["EQ", "NEQ", "GT", "GE", "LT", "LE"])
#foreach($opcode in $opcodes)
    infix fun ${opcode.toLowerCase()}(other: $self) = binary(SMTEngine.Opcode.$opcode, other).toBool()
#end
#set($opcodes = ["ADD", "SUB", "MUL", "DIVIDE"])
#foreach($opcode in $opcodes)
    infix fun ${opcode.toLowerCase()}(other: $self) = binary(SMTEngine.Opcode.$opcode, other).to$float()
#end

    operator fun plus(other: $self) = add(other)
    operator fun minus(other: $self) = sub(other)
    operator fun times(other: $self) = mul(other)
    operator fun div(other: $self) = divide(other)
}

#end

#set($self = $Array)
class $self< Element : $valexpr, in Index : $valexpr > : $valexpr {
    companion object {
        fun < Element : $valexpr, Index : $valexpr > merge(default: $self< Element, Index >,
            cases: List< Pair< $Bool, $self< Element, Index >>>): $self< Element, Index > {
            return cases.fold(default) { acc, pair ->
                val ctx = pair.first.ctx
                $self(ctx, engine.ite(ctx, pair.first.expr, acc.expr, pair.second.expr), spliceAxioms(ctx, acc.axiom, pair.second.axiom))
            }
        }

        inline fun < Element : $valexpr, reified Index : $valexpr > makeDefault(ctx: $context, name: String, default: Element) =
            $self< Element, Index >(ctx, ${solver}Engine.makeConstArray(ctx, ${valexpr}.getStaticSort< Index >(ctx), default.expr))

        inline fun < reified Element : $valexpr, reified Index : $valexpr > makeFree(ctx: $context, name: String): $self< Element, Index > {
            val sort = ${solver}Engine.getArraySort(ctx, ${valexpr}.getStaticSort< Element >(ctx), ${valexpr}.getStaticSort< Index >(ctx))
            return $self< Element, Index >(ctx, ${solver}Engine.makeVar(ctx, sort, name, true))
        }

        inline fun < reified Element : $valexpr, reified Index : $valexpr > makeVar(ctx: $context, name: String): $self< Element, Index > {
            val sort = ${solver}Engine.getArraySort(ctx, ${valexpr}.getStaticSort< Element >(ctx), ${valexpr}.getStaticSort< Index >(ctx))
            return $self< Element, Index >(ctx, ${solver}Engine.makeVar(ctx, sort, name, false))
        }
    }

    #constructors("Array")

    fun load(index: Index) = $valexpr(ctx, engine.load(ctx, expr, index.expr))

    fun store(index: Index, value: Element): $self< Element, Index > =
        $self(ctx, engine.store(ctx, expr, index.expr, value.expr))

    fun store(cases: List< Pair< Index, Element >>):$self< Element, Index > {
        val base: $expr = cases.fold(expr) { expr, pair -> engine.store(ctx, expr, pair.first.expr, pair.second.expr) }
        return $self(ctx, base)
    }

    operator fun get(index: Index) = load(index)
    operator fun set(index: Index, value: Element) = store(index, value)
}

inline fun < reified T : $valexpr > ${valexpr}.convert() = when (T::class) {
    $Bool::class -> toBool() as T
    $Bitvector32::class -> toBV(${Bitvector32}.getStaticSort(ctx)) as T
    $Bitvector64::class -> toBV(${Bitvector64}.getStaticSort(ctx)) as T
    $Bitvector::class -> toBV() as T
    $Float::class -> toFloat() as T
    $Double::class -> toDouble() as T
    else -> unreachable { log.error("Unknown expression type") }
}

fun ${valexpr}.convert(sort: $sort) = when {
    engine.isBoolSort(ctx, sort) -> toBool()
    engine.isBVSort(ctx, sort) -> toBV(sort)
#foreach($float in $floats)
    engine.is${float}Sort(ctx, sort) -> to$float()
#end
    else -> unreachable { log.error("Trying to convert value to unknown sort") }
}

fun ${valexpr}.toBool(): $Bool {
    val newExpr = when {
        engine.isBool(ctx, expr) -> expr
        engine.isBV(ctx, expr) -> engine.bv2bool(ctx, expr)
        else -> unreachable { log.debug("Unexpected SMT expr type in cast") }
    }
    return $Bool(ctx, newExpr, axiom)
}

fun ${valexpr}.toBV(sort: $sort): $Bitvector {
    val newExpr = when {
        engine.isBool(ctx, expr) -> engine.bool2bv(ctx, expr, sort)
        engine.isBV(ctx, expr) -> engine.bv2bv(ctx, expr, sort)
        engine.isFP(ctx, expr) -> engine.float2bv(ctx, expr, sort)
        else -> unreachable { log.debug("Unexpected SMT expr type in cast") }
    }
    return $Bitvector(ctx, newExpr, axiom)
}

fun ${valexpr}.toBV(): $Bitvector {
    val newExpr = when {
        engine.isBool(ctx, expr) -> engine.bool2bv(ctx, expr, engine.getBVSort(ctx, SMTEngine.WORD))
        engine.isBV(ctx, expr) -> this.expr
        engine.isFloat(ctx, expr) -> engine.float2bv(ctx, expr, engine.getBVSort(ctx, SMTEngine.WORD))
        engine.isDouble(ctx, expr) -> engine.float2bv(ctx, expr, engine.getBVSort(ctx, SMTEngine.DWORD))
        else -> unreachable { log.debug("Unexpected SMT expr type in cast") }
    }
    return $Bitvector(ctx, newExpr, axiom)
}

fun ${valexpr}.toFloat(): $Float {
    val newExpr = when {
        engine.isBV(ctx, expr) -> engine.bv2float(ctx, expr, engine.getFloatSort(ctx))
        engine.isFloat(ctx, expr) -> this.expr
        engine.isDouble(ctx, expr) -> engine.float2float(ctx, expr, engine.getFloatSort(ctx))
        else -> unreachable { log.debug("Unexpected SMT expr type in cast") }
    }
    return $Float(ctx, newExpr, axiom)
}

fun ${valexpr}.toDouble(): $Double {
    val newExpr = when {
        engine.isBV(ctx, expr) -> engine.bv2float(ctx, expr, engine.getDoubleSort(ctx))
        engine.isFloat(ctx, expr) -> engine.float2float(ctx, expr, engine.getDoubleSort(ctx))
        engine.isDouble(ctx, expr) -> this.expr
        else -> unreachable { log.debug("Unexpected SMT expr type in cast") }
    }
    return $Double(ctx, newExpr, axiom)
}