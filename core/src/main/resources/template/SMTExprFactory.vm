#parse("definitions.vm")
import org.jetbrains.research.kex.util.loggerFor
import org.jetbrains.research.kex.smt.${solver}SMTExprFactory
import org.jetbrains.research.kfg.ir.Class

typealias Bool_ = $Bool
typealias Ptr_ = $Bitvector32
typealias Short_ = $Bitvector32
typealias Int_ = $Bitvector32
typealias Long_ = $Bitvector64
typealias Float_ = $Float
typealias Double_ = $Double
typealias Memory_ = $Memory< Ptr_ >
typealias Dynamic_ = $valexpr

class $factory : ${solver}SMTExprFactory(), Loggable {
    companion object {
        private val classOffsets = mutableMapOf< Class, MutableMap< Class.FieldKey, Int >>()

        fun getFieldOffset(`class`: Class, field: Class.FieldKey) = classOffsets.getOrPut(`class`) {
            val offsets = mutableMapOf< Class.FieldKey, Int >()
            var offset = 0
            for (key in `class`.fields.keys) {
                offsets[key] = 0
                offset += getTypeSize(key.type)
            }
            offsets
        }.getValue(field)

        fun getTypeSize(type: Type) = when (type) {
            is LongType -> SMTEngine.DWORD
            is Integral -> SMTEngine.WORD
            is FloatType -> SMTEngine.WORD
            is DoubleType -> SMTEngine.DWORD
            is Reference -> SMTEngine.WORD
            else -> unreachable { loggerFor(Z3ExprFactory::class).error("Unexpected type: $type") }
        }

        fun getTypeSizeExpanded(type: Type) = when (type) {
            is ClassType -> type.`class`.fields.keys.fold(0) { acc, fieldKey -> acc + getTypeSize(fieldKey.type) }
            else -> getTypeSize(type)
        }
    }

    val ctx = $context()

#macro(generateMakes $type $basetype)
    #set($underlined = "${type}_")
    fun make$type(name: String, fresh: Boolean = false) =
            if (fresh) ${underlined}.makeFreshVar(ctx, name) else ${underlined}.makeVar(ctx, name)
    fun make${type}Const(value: $basetype) = ${underlined}.makeConst(ctx, value)
#end

#generateMakes("Ptr" "Int")
    fun makeNull() = makePtrConst(0)

#generateMakes("Bool", "Boolean")
    fun makeTrue() = makeBoolConst(true)
    fun makeFalse() = makeBoolConst(false)

#generateMakes("Short", "Int")
    fun makeShortConst(value: Short) = makeShortConst(value.toInt())

#generateMakes("Int", "Int")

#generateMakes("Long", "Long")

#generateMakes("Float", "Float")

#generateMakes("Double", "Double")

    fun makeEmptyMemory(id: String) = Memory_.makeFree < Ptr_ >(ctx, id)
    fun makeDefaultMemory(id: String, default: Int) =
        Memory_.makeDefault< Ptr_ >(ctx, id, Byte_.makeConst(ctx, default))

#set($types = ["Bool", "Short", "Int", "Long", "Float", "Double"])
    fun getVarByType(type: Type, name: String, fresh: Boolean = false) = when(type) {
#foreach($type in $types)
        is ${type}Type -> make${type}(name, fresh)
#end
        is ClassType -> makePtr(name, fresh)
        is ArrayType -> makePtr(name, fresh)
        else -> unreachable { log.error("Unknown type in ExprFactory: $type") }
    }

    inline fun < T : Dynamic_, reified U : Dynamic_ > switch(value: T, cases: Map< T, U >, default: U) =
        cases.toList().fold(default) { acc, pair -> `if`(value eq pair.first).then(pair.second).`else`(acc) }

    inline fun < reified U : Dynamic_ > switch(cases: Map< Bool_, U >, default: U) =
        cases.toList().fold(default) { acc, pair -> `if`(pair.first).then(pair.second).`else`(acc) }
}
